/*
 * TITLE:       callbacks.cc
 *
 * PURPOSE:     This file contains the callback functions that hook to the signals
 *              as setup in glade.
 *
 * WRITTEN BY:  Brett Browning, modified from {James Bruce} Small Size code 2001
 *              Generated by Glade
 */
/* LICENSE:
  =========================================================================
    CMDragons'02 RoboCup F180 Source Code Release
  -------------------------------------------------------------------------
    Copyright (C) 2002 Manuela Veloso, Brett Browning, Mike Bowling,
                       James Bruce; {mmv, brettb, mhb, jbruce}@cs.cmu.edu
    School of Computer Science, Carnegie Mellon University
  -------------------------------------------------------------------------
    This software is distributed under the GNU General Public License,
    version 2.  If you do not have a copy of this licence, visit
    www.gnu.org, or write: Free Software Foundation, 59 Temple Place,
    Suite 330 Boston, MA 02111-1307 USA.  This program is distributed
    in the hope that it will be useful, but WITHOUT ANY WARRANTY,
    including MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
  ------------------------------------------------------------------------- */

/*
 * Initial main.c file generated by Glade. Edit as required.
 * Glade will not overwrite this file.
 */
#ifdef HAVE_CONFIG_H
#  include <config.h>
#endif

#include <gtk/gtk.h>
#include <gdk/gdkkeysyms.h>
#include <stdio.h>

#include "callbacks.h"
#include "interface.h"
#include "support.h"
#include "main.h"
#include "gtkutils.h"

//#define DEBUG

/************************************* TYPES *************************************/


/************************************* GLOBALS ***********************************/
int lastbutton = 0;
GdkPoint lastpoint;


/************************************* PROTOTYPES ********************************/


/************************************* MAin Callbacks ****************************/


/*
 * OnRawToggle -
 *
 * This function
 */
void OnRawToggle(GtkToggleButton *togglebutton, gpointer user_data)
{
#ifdef DEBUG
  fprintf(stderr, "OnRawToggle\n");
#endif

  showsegmentation = !showsegmentation;

  if (showsegmentation)
    UpdateStatusBar(statusbar, "Showing color image...");
  else
    UpdateStatusBar(statusbar, "Showing raw image...");
}


/*
 * OnSaveImageClicked -
 *
 * This function
 */
void OnSaveImageClicked(GtkButton *button, gpointer user_data)
{
#ifdef DEBUG
  fprintf(stderr, "OnSaveImageClicked\n");
#endif

  UpdateStatusBar(statusbar, "Saving image unimplemented...");
}


/*
 * OnVideoToggle -
 *
 * This function
 */
void OnVideoToggle(GtkToggleButton *togglebutton, gpointer user_data)
{
#ifdef DEBUG
  fprintf(stderr, "OnVideoToggle\n");
#endif

  //  UpdateStatusBar(statusbar, "Video toggle unimplemented...");
}


/*
 * OnChannelApplyClicked -
 *
 * This function
 */
void OnChannelApplyClicked(GtkButton *button, gpointer user_data)
{
#ifdef DEBUG
  fprintf(stderr, "OnChannelApplyClicked\n");
#endif
  UpdateStatusBar(statusbar, "Saving image unimplemented...");
}


/*
 * OnColorFileActivate -
 *
 * This function
 */
void OnColorFileActivate(GtkEditable *editable, gpointer user_data)
{
#ifdef DEBUG
  fprintf(stderr, "OnColorFileActivate\n");
#endif

}


/*
 * OnColorFileLoad -
 *
 * This function
 */
void OnColorFileLoad(GtkButton *button, gpointer user_data)
{
#ifdef DEBUG
  fprintf(stderr, "OnColorFileLoad\n");
#endif
  char fname[256];
  strcpy(fname, configdir);
  if (fname[strlen(fname) - 1] != '/')
    strcat(fname, "/");
  strcat(fname, gtk_entry_get_text(GTK_ENTRY(colorfile)));

  if (!dhistogram.Load(fname)) {
    UpdateStatusBar(statusbar, "Cannot load file!");
    fprintf(stderr, "ERROR: cannot load file %s\n", gtk_entry_get_text(GTK_ENTRY(colorfile)));
  }

  dhistogram.Redraw();

  UpdateStatusBar(statusbar, "Loading colormap %s", gtk_entry_get_text(GTK_ENTRY(colorfile))); 
}


/*
 * OnColorFileSave -
 *
 * This function
 */
void OnColorFileSave(GtkButton *button, gpointer user_data)
{
#ifdef DEBUG
  fprintf(stderr, "OnColorFileSave\n");
#endif

  dhistogram.Save(gtk_entry_get_text(GTK_ENTRY(colorfile)));
  UpdateStatusBar(statusbar, "Saving colormap to %s", gtk_entry_get_text(GTK_ENTRY(colorfile))); 
}

/*
 * OnColorFileSaveAs -
 *
 * This function
 */
void OnColorFileSaveAs(GtkButton *button, gpointer user_data)
{
#ifdef DEBUG
  fprintf(stderr, "OnColorFileSaveAs\n");
#endif

}

/************************************* COLORMAP Callbacks *****************************/

/*
 * OnCMapConfigure -
 *
 * This function
 */
gboolean OnCMapConfigure(GtkWidget *widget, GdkEventConfigure *event, gpointer user_data)
{
#ifdef DEBUG
  fprintf(stderr, "OnCMapConfigure\n");
#endif

  dhistogram.Reconfigure();

  return FALSE;
}

/*
 * OnCMapButtonPress -
 *
 * This function
 */
gboolean OnCMapButtonPress(GtkWidget *widget, GdkEventButton  *event, gpointer user_data)
{
#ifdef DEBUG1
  fprintf(stderr, "OnCMapButtonPress\n");
#endif

  GdkPoint p;
  p.x = (gint16) event->x;
  p.y = (gint16) event->y;

  lastbutton = event->button;
  switch (event->button) {
  case 1:
    dhistogram.DrawPoint(p);
    dhistogram.Draw();
    dhistogram.Redraw();
    lastpoint = p;
    UpdateStatusBar(cmapstatusbar, "Drawing point color %i, level %i", 
		    dhistogram.GetColor(), dhistogram.GetDisplayLevel());
    break;
  case 2:
    dhistogram.DrawPaint(p);
    dhistogram.Draw();
    dhistogram.Redraw();
    UpdateStatusBar(cmapstatusbar, "Painting color %i, level %i", 
		    dhistogram.GetColor(), dhistogram.GetDisplayLevel());
    break;
  case 3:
    dhistogram.SetColor(p);
    UpdateStatusBar(cmapstatusbar, "Set color to %i, level %i", 
		    dhistogram.GetColor(), dhistogram.GetDisplayLevel());
    break;
  }


  return FALSE;
}


/*
 * OnCMapMotion -
 *
 * This function
 */
gboolean OnCMapMotion(GtkWidget *widget, GdkEventMotion  *event, gpointer user_data)
{
#ifdef DEBUG1
  fprintf(stderr, "OnCMapMotion\n");
#endif

  GdkPoint p;
  p.x = (gint16) event->x;  
  p.y = (gint16) event->y;

  if (lastbutton == 1) {
    dhistogram.DrawLine(lastpoint, p);
    lastpoint = p;
    dhistogram.Redraw();

  }

  return FALSE;
}

/*
 * OnCMapMotion -
 *
 * This function just redraws the histogram display when required
 */
gboolean OnCMapExpose(GtkWidget *widget, GdkEventExpose *event, gpointer user_data)
{
  printf("expose...\n");

  dhistogram.Redraw(event);

  return FALSE;
}

/*
 * OnColorIDButton -
 *
 * This function
 */
void OnColorIDButton(GtkButton *button, gpointer user_data)
{
  int up = GPOINTER_TO_INT(user_data);

#ifdef DEBUG1
  fprintf(stderr, "OnColorIDButton %i, %i\n", up, dhistogram.GetDisplayLevel());
#endif
  if (up > 0)
    dhistogram.IncrementDisplayLevel();
  else
    dhistogram.DecrementDisplayLevel();
  dhistogram.Redraw();
  UpdateStatusBar(cmapstatusbar, "color to %i, level %i", 
		  dhistogram.GetColor(), dhistogram.GetDisplayLevel());

}


void OnCMapIntensityClicked(GtkButton *button, gpointer user_data)
{
  int up = GPOINTER_TO_INT(user_data);

  if (up > 0)
    dhistogram.IncrementColor();
  else
    dhistogram.DecrementColor();
  dhistogram.Redraw();
  UpdateStatusBar(cmapstatusbar, "color to %i, level %i", 
		  dhistogram.GetColor(), dhistogram.GetDisplayLevel());
}

/*
 * OnImageButtonPress -
 *
 * This function
 */
gboolean OnImageButtonPress(GtkWidget *widget, GdkEventButton  *event, gpointer user_data)
{
#ifdef DEBUG
  fprintf(stderr, "OnImageButtonPress %i at %1.0f, %1.0f\n", event->button, event->x, event->y);
#endif

  switch (event->button) {
  case 1:
    if (dparam.isShowing){
      dparam.GetClosestPoint((int)event->x,(int)event->y);
      UpdateStatusBar(statusbar, "Click on point %s  new location" , 
		      dparam.descrip[dparam.clickedI]);
      //printf("23 : %d, %d", dparam.coord[23].x, dparam.coord[23].y);
      grabone = true;
    } else {

      rgb rgbc;
      yuv yuvc = GetLocation((int) event->x, (int) event->y, rgbc);
      UpdateStatusBar(statusbar, "Color at (%i, %i) YUV = (%i, %i, %i), RGB = (%i, %i, %i)",
		      (int) event->x, (int) event->y, yuvc.y, yuvc.u, yuvc.v, 
		      rgbc.red, rgbc.green, rgbc.blue);
    }
    break;
  case 3: //dinesh

    dparam.GetClosestPoint((int)event->x,(int)event->y);
    
    if (dparam.isClicked){
      UpdateStatusBar(statusbar, "Click on point %s  new location" , 
		      dparam.descrip[dparam.clickedI]);
      //printf("23 : %d, %d", dparam.coord[23].x, dparam.coord[23].y);
    } else {
      UpdateStatusBar(statusbar, "Location clicked was: (%i, %i)",(int) event->x, (int) event->y);
    }

    break;
  }

  return FALSE;
}

gboolean on_image_area_button_release_event(GtkWidget *widget, GdkEventButton  *event,
					    gpointer user_data)
{
  dparam.isClicked = false;
  grabone = true;

  return FALSE;
}



gboolean on_image_area_motion_notify_event(GtkWidget *widget, GdkEventMotion  *event, 
					   gpointer user_data)
{
  if (dparam.isClicked && dparam.isShowing) {
    dparam.GetClosestPoint((int)event->x,(int)event->y);
    //    grabone = true;
  }

  return FALSE;
}



/*
 * OnImageConfigure -
 *
 * This function
 */
gboolean OnImageConfigure(GtkWidget *widget, GdkEventConfigure *event, gpointer user_data)
{
#ifdef DEBUG
  fprintf(stderr, "OnImageConfigure\n");
#endif

  return FALSE;
}

// this doesn't seem to be getting caled?
gboolean OnKeyPress(GtkWidget *widget, GdkEventKey *event, gpointer user_data)
{
#ifdef DEBUG
  fprintf(stderr, "KeyPress\n");
#endif

  switch (event->keyval) {
  case GDK_space:
    printf("capture frame...\n");
    grabbing = !grabbing;
    grabone = false;
    break;
  case GDK_g:
    printf("capture 1 frame...\n");
    grabbing = false;
    grabone = true;
    break;
  case GDK_c:
    printf("color output...\n");
    showsegmentation = true;
    break;
  case GDK_v:
    printf("capture frame...\n");
    showsegmentation = false;
    break;
  case GDK_Escape:
    Quit();
    break;
  }
  return FALSE;
}

gboolean OnImageExpose(GtkWidget *widget, GdkEventExpose *event, gpointer user_data)
{
#ifdef DEBUG1
  fprintf(stderr, "ImageExpose\n");
#endif

  drawrgb.ReDraw();

  // dinesh . Call your redraw function here so that it gets displayed when people move the window
  //  dparam.Draw();
  //  dparam.ReDraw();

  return FALSE;
}

/*
 * OnQuit -
 *
 * Shutdown everything by calling the shutdown function
 */
void OnQuit(GtkObject *object, gpointer user_data)
{
  Quit();
}


void OnParamsActivate(GtkEditable *editable, gpointer user_data)
{
#ifdef DEBUG
  fprintf(stderr, "OnParamsActivate\n");
#endif

}


void OnParamsLoad(GtkButton *button, gpointer user_data)
{
#ifdef DEBUG
  fprintf(stderr, "OnParamsLoad\n");
#endif
  char fname[256];
  strcpy(fname, configdir);
  if (fname[strlen(fname) - 1] != '/')
    strcat(fname, "/");
  strcat(fname, gtk_entry_get_text(GTK_ENTRY(paramsfile)));

  if (!dparam.LoadFile(fname)) {
    UpdateStatusBar(statusbar, "Cannot load file!");
    fprintf(stderr, "ERROR: cannot load file %s\n", fname);
    dparam.isShowing = false;
  } else {
    dparam.isShowing = true;
    grabone = true;
  }
}


void OnParamsSave(GtkButton *button, gpointer user_data)
{
#ifdef DEBUG
  fprintf(stderr, "OnPAramsSave\n");
#endif

  if (dparam.isShowing) {
    char fname[256];
    strcpy(fname, configdir);
    if (fname[strlen(fname) - 1] != '/')
      strcat(fname, "/");
    strcat(fname, gtk_entry_get_text(GTK_ENTRY(paramsfile)));

    if (dparam.SaveFile(fname)) {
      UpdateStatusBar(statusbar, "Saved to file %s", fname);
    } else {
      fprintf(stderr, "Cannot save to file %s\n", fname);
      UpdateStatusBar(statusbar, "Cannot save to file %s", fname);
    } 
  }
}


void OnParamsSaveAs(GtkButton *button, gpointer user_data)
{
#ifdef DEBUG
  fprintf(stderr, "OnPAramsSaveAs\n");
#endif

}


void OnGrabClicked(GtkButton *button, gpointer user_data)
{
#ifdef DEBUG
  fprintf(stderr, "OnGrabClicked\n");
#endif

  if (user_data == 0)
    grabone = true;
  else
    grabbing = !grabbing;

  if (grabbing)
    UpdateStatusBar(statusbar, "Grabbing image data..."); 
  else
    UpdateStatusBar(statusbar, "Stopped Grabbing image data..."); 
}




